

App name: Weather App.
About: A small app to check the weather on your location.

APIs used: 
	-com.android.support.design:28.0.0
	-com.google.android.gms:play-services-location:16.0.0
	-OpenWeatherMap
	-FusedLocationApi over android legacy Location api.
	(For more, please, see the app's build.gradle file).
	
Summary:


Using OpenWeatherMap Api (https://openweathermap.org/) we create a small but simple weather app
where we can check the current location weather in real time, and/or non real time.

For real-time mode: We need the Gps ON, then we retrieve the location and the weather, using Google's FusedLocationClient api and connecting to OpenWeatherMap for a weather reading. 
We will get a JSON response (could also be XML, but we stick to JSON this time) that we use for show on the app UI. 
The system will get a snapshot of such weather with a timestamp, valid for 24 hours.

For non-real-time: It is required to have had to use our app within the latest 24 hours. 
If the app happens to have a snapshot of the weather consultation that's younger than 24 HOURS, it will be used.
If the snapshot is older it will be discarded and not used.
If there's no snapshot, NO DATA will be shown.

Engineering decisions:

-We require the usage of google play services, therefore the app will look for it but you can still use the app with probable malfunctioning (very unlikely since most of phones do have google play services);

-The offline system uses shared preferences but a database is implemented to achieve the same goal (this can be changed by commenting this line  		setOffLineSystem(mWeather=mDataFlowController.getWeatherFromSharedPreferences());
and uncommenting the line setOffLineSystem(mWeather=readFromDatabase(null,null));
, both lines within the "enableGps()" method in MainActivity.java file.

-JSON is chosen over XML when parsing the weather server's answer (personal preference).
Thought of using GSON library for example, but didn't because the space required by the files to download, isn't worth the amount of code we will write (10 lines).

-Because the location service will only return one answer when we open the app or when we hit the "reload" button, battery shouldn't be drained, besides the battery required by the GPS hardware.

-Together with the JSON comes the name of an image file. We can download them (thought of using 
Picasso or library third party API's. Didnt't do it, downloaded the pictures instead. 
It's not worth it for a single picture and in case our device doesnt have internet connection and our weather snapshot is within 24 hours (means still usable), we can use the files locally. 
Obviously, that makes the app's size somewhat bigger.

-Due to the server answer in Kelvin degrees, timestamps instead of dates and wind direction degrees in number instead of Directions (N, S, W, E), some methods have been created for convenience.

-Fetching data from weather server, internet connection to achieve it, unit conversions and a "loading" view are done by using an implementation of an AsyncTask as we dont require a service which is a heavy object in terms of workload and memory usage.
AsyncTask is lightweight and achieves its goal quickly to stop afterwards.

-The "loading" progress bar is almost impossible to see due to the speed of the AsyncTask so i created a TimerTask with a Runnable that keeps it working for 0.5 seconds after the AsyncTask finishes fetching data. 

-We use an HttpsConnection within the AsyncTask to connect with the weather server and download its data into an array of bytes that will be converted into a string, to be (JSON) parsed later.
	


Other implementations not done because of lack of time:

-Implementing the location system using the legacy api instead of using google play services for retrocompatibility.

-Make app visually nicer or better and good looking, more attractive for the user experience. 

-Implementing blinking animation for "Loading..." text and a new horizontal ProgressBar underneath with load percentage.

-Implementing a ToolBar or a BottomNavigationView or MenuItem's to add a menu to search for weather in the future (as much as the OpenWeatherMap API allows us).
	An EditText to type the city name would be also valid.

-Adding new screens via fragment and a View pager to pass through the next days weather forecast.

-Using GSON third party library to parse JSON from weather server.


Reports Folder contain coverage reports.

TESTING:

-Testing has been made with JUnit (test file is /WeatherApp/app/src/test/java/com/juan/weatherapp/BaseUnitTests.java)
-Instrumented test file is /WeatherApp/app/src/androidTest/java/com/juan/weatherapp/InstrumentedTest.java
-Multiple methods accross the app have been marked public instead of private for the sake of testing.
-Added extra base constructors on MainActivity and SingletonClass for testing reasons (they can be erased and has notes next to them indicating to do so).
-Last three instrumented tests won't pass as they require using other elements from the app (views and other classes) to be initialized in the methods they test.
Doing so is ok but would take a long time and reestructuring the app and for the length of the code, I find it worthless as it can be tested on runtime (the app won't work properly if those methods don't work).
These tests are: location_test(), test_enable_gps() and test_deployment(). All of them commented out. Uncomment in case we want to try them or simply enhance the code to make them useful.
-For testing reasons, I enabled the write/read methods from class "DataFlowController" named  writeToDatabase(...) and readFromDataBase(...) but I leave them disabled within the method MainActivity.enableGps()
 and MainActivity.getLocation() (take special care if performing coverage tests as this will be disabled).
As mentioned above, caching weather will be done with sharedpreferences but using a local database instead (or together but pointless) is possible with by commenting/uncommenting these methods callings.




